 -----
 Environment support plugin
 -----
 -----
 28 Jan 2008
 -----

Environment support plugin

  The Environment plugin is used to have the same environment variables 
  available (1) in maven for build system tasks and (2) while applications are running.
  
  Typically an environment variable is defined as a property in a maven pom file.
  Here is an example:
  
+----------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    ...
    
    <properties>
        <rmi.host>localhost</rmi.host>
        <rmi.port>8099</rmi.port>
        
        <db.username>refdb_user</db.username>
        <db.password>my_secret_password</db.password>
        
        ...
        
    </properties>
</project>
+----------------

  To have the (maven) properties <<<rmi.host>>> and <<<rmi.port>>> also available during 
  application runtime we have to <share> these properties between the 2 "worlds" 
  (maven and the application runtime). In EL4J this is done
  the Spring way via a properties file. The EL4J <<env-module>> expects the
  file <<<env-placeholder.properties>>> in the classpath.
  
  Maven is able to filter resources which means that placeholders will be 
  replaced by their values. To have the properties <<<rmi.host>>> and 
  <<<rmi.port>>> with exactly the same name during runtime we have to write the 
  <<<env-placeholder.properties>>> file like this:
  
+----------------
rmi.host=${rmi.host}
rmi.port=${rmi.port}
+----------------

  You already know the path <<<src/main/resources>>>. Resources placed in this
  path will be copied 1:1 to the place where the compiled Java sources are 
  (by default <<<target/classes>>>). Now we have a similar path <<<src/main/env>>>.
  Resources in this path will be copied and filtered i.e. the placeholders will be
  replaced. The default target path for filtered files is <<<target/env>>>. This
  path is handled like the <<<src/main/resources>>> path. To have this behavior
  we must define the following in our parent pom (this is already made in 
  the <root> pom of EL4J):
  
+----------------
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>

    ...

    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>false</filtering>
            </resource>

            <!-- Used for the environment support of EL4J -->
            <resource>
                <directory>target/env</directory>
                <filtering>false</filtering>
            </resource>
        </resources>
        <testResources>
            <testResource>
                <directory>src/test/resources</directory>
                <filtering>false</filtering>
            </testResource>

            <!-- Used for the environment support of EL4J -->
            <testResource>
                <directory>target/env-test</directory>
                <filtering>false</filtering>
            </testResource>
        </testResources>
    </build>
    
    ...
    
</project>
+----------------

  To complete the example above, we have to place the
  <<<env-placeholder.properties>>> file in <<<src/main/env>>>.
  
  The filtered <<<env-placeholder.properties>>> file will then look like the
  following and can be found at <<<target/env>>>.
  
+----------------
rmi.host=localhost
rmi.port=8099
+----------------

  If you create an Eclipse project for your non-pom artifact you will have the path
  <<<target/env>>> as source folder available. Through this you can clean your Eclipse
  project without loosing the filtered file.
  
  [Test scope] The equivalent part for the test scope must be placed in 
  <<<src/test/env>>> and filtered files will be placed by default in 
  <<<target/env-test>>>.
  
  [Overriding bean properties] In the same directory as the
  <<<env-placeholder.properties>>> files you can place another properties 
  file with name <<<env-bean-property.properties>>>. Properties in this file
  will be used to override Spring bean properties (like Spring's 
  PropertyOverrideConfigurer). 
  Here is an example:

+----------------
dataSource.username=${db.username}
dataSource.password=${db.password}
dataSource.url=${db.url}
+----------------

  The bean properties <<<username>>> and <<<password>>> of the bean <<<dataSource>>>
  will then be overridden. BTW the value of <<<db.url>>> is already set when using the 
  corresponding database profile of the EL4J (root) pom (by default it is set to db2 
  (which is equivalent to derby)).
  
  [Global environment resource directory] You can define to use a global resource
  directory so you do not have to have the <<<src/main/env>>> path in each artifact.
  But be aware that you have the <<<env-placeholder.properties>>> file only one time in 
  your classpath (otherwise you will get a warning and the wrong properties file may be 
  chosen)!
  
  []
  
  For detailed usage {{{plugin-info.html}see the plugin info page}}.
