H1 Synchronization

Synchronize ensures that, unless there is a conflict,
- All changes made in the local database are written to the server.
- All offlined objects that have in the meantime been updated on the server are updated in the local database too.

If there is a conflict,
- All objects that have been updated both in the local database and on the server cause a Conflict.

During the whole of a synchronize operation, neither local nor database data should be externally modified.

Each object - identified uniquely by the pair (class, PK) - is processed exactly once by the synchronization process. (However, if an object's save results in a cascade, these extra saves are not under the control of the synchronization process.) 

H2 Phases
Synchronization runs in three phases. If a conflict occurs in a phase, subsequent phases are skipped. This allows us to assume previous phases were successful and depend on them in later phases.

The phases are 
1. Synchronize changed data in the local database.
2. Synchronize deleted data in the local database.
3. Synchronize unchanged data in the local database.

H3 Changed data
All objects that have been changed in the local database are passed to the server once for synchronization. They can either be successful or fail. This step runs as in offliner 1.1 except that the metadata may be differently implemented and organized. Further the metadata is updated by the server as, unlike 1.1, it is not deleted but written back after the synchronization.

From the database's point of view, it must act as if the objects had been loaded by the user, modified and saved back directly. In particular, an object's id and version must be the same when synchronize saves it back than when the user offlined it. 

H3 Deleted data
This is the simplest to process. All deleted objects are deleted on the server in the order they were deleted on the client using the metadata.

H3 Unchanged data
The issue here is that it may have been changed on the server thus producing stale data on the client. This phase only runs when the previous two completed successfully so we can never get a client-side conflict in this phase. 

All unchanged entries are queried by version from the server which checks if they have been updated and sends them for updating if they have.

H2 Conflict resolution
There are several resolutions for confclicts. The former concern objects updated both on the client and the server since the last sync, the latter deletion conflicts.

For an object updated both on the client and the server, we recommend showing the user the two versions and deciding which one he wants to keep. Then, calling either forceLocal or forceRemote forces the given version to overwrite the other ignoreing versions. This requires some trickery to break hibernate's optimistic locking and must only be done during a period of time when you have an exclusive lock on the database. Note that force only forces the object passed as parameter. If it failed to sync because something it depends on failed, you must sort out the source of the conflict first before dealing with dependent conflicts.

Deletion fails in the following scenario: On the server you have objects A and B where a depends on B. You offline only B and delete it in the local database. This is ok because there is no A there. On sync, the offliner tries to delete B in the database and gets a constraint violation from A. You have two options: Delete A manually on the server and resync, or declare the deletion of B void. After you have deleted all you want to delete on the server, eraseDeletes declares all pending deletions void.
