This page contains specifications for the offliner.

H1 Functionality

A offliner implementation adds offlining functionality to a database accessed via DAOs. 

To use offlining, the client must get his DAOs from the offliner by using it as a DaoRegistry. These DAOs must not be offlined by the client between state changes in the offliner (which the client initiates).

An offliner has two states: online and offline. In online mode, it forwards all calls to DaoRegistry.getFor(Class) to the database's DaoRegistry. In offline mode, the offliner returns DAOs for a local database. At all times, the offliner's DaoRegistry implementation is guaranteed to return a valid DAO for the active database (if one exists).

The offliner offers two offlining methods: offline and synchronize.

After performing a set of offline operations, the client may go offline and work with the local database. He can perform multiple offline or synchronize operations in sequence. 

H2 Offline 

See the separate documentation.

H2 Synchronize

See the separate documentation.

H2 Deleting

There are two kinds of delete imaginable on the local database:

The first is removing an object to prevent it from being resynchronized, to cancel local changes, or simply because we do not need it in the local database anymore. This kind of delete functions as if the object had never been offlined and is accessible over Offliner.evict()=.

The second is requesting an object be deleted from the server, in which case the offliner has to mark it as deleted and process the deletion on synchronization. This is currently implemented by wrapping all local DAOs and firing =Offliner.markforDeletion()= in the delete methods.

H2 Conflicts
A conflict can occur on offlining or synchronizing the local with the remot database. It represents an object that caused an exception while trying to save it. 

Exceptions during =synchronize= that occur in a =saveOrUpdate= or =delete= operation are caught by the offliner and wrapped in conflict objects. These contain, at least, the original exception, the phase during which the exception occurred and the object that caused the exception if present (the only time it is not present is if we are trying to delete an object, already deleted on the client, on the server). One special case is dependent conflicts: If an object has one or more children that caused a conflict, the parent object is automatically marked as conflicted and it is not even attempted to save to the database. 

=synchronize()= returns a =Conflict[]= that is of length 0 if the operation was successful, otherwise it contains all conflicts that occurred. For each conflicted object, exactly one conflict must be returned. If an object is both locally and dependently conflicted, the dependent conflict takes precedence as no attempt can be made to save a dependently conflicted object.
